package main;

import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;

import util.Feature;
import util.WeatherData;

public class GainRaio 
{
  private Feature feature2consider;
  private double partitionPoint;
  private double gainRatio = roundoff(Double.MIN_VALUE);
  private HashMap<Integer,WeatherData> XDataInTrain = new HashMap<Integer,WeatherData>();
  private HashMap<Integer,WeatherData> YDataInTrain = new HashMap<Integer,WeatherData>();
  
  public  double calcInformationRatio(HashMap<Integer,WeatherData> trainDataX,HashMap<Integer,WeatherData> trainDataY,
		                              Feature attribute,String target_val) throws IOException
  {
	  this.feature2consider = attribute;
	  this.XDataInTrain = trainDataX;
	  this.YDataInTrain = trainDataY;
	  sortTrainXYData(attribute);
  }
  private void sortTrainXYData(Feature attrb)
  {
	  Comparator<HashMap<Integer,WeatherData>> comparator = new Comparator<HashMap<Integer,WeatherData>>()
		{
		  @Override
			public int compare(HashMap<Integer,WeatherData> x, HashMap<Integer,WeatherData> y) 
			{
				HashMap<String, String> xPair = x.getAttributeValuePairs();
				String xValue = xPair.get(attributeName);
						
				HashMap<String, String> yPair = y.getAttributeValuePairs();
				String yValue = yPair.get(attributeName);
				if (Double.parseDouble(xValue) - Double.parseDouble(yValue) > 0) return 1;
				else if (Double.parseDouble(xValue) - Double.parseDouble(yValue) < 0) return -1;
				else return 0;
			}
		};
		Collections.sort(this.XDataInTrain, comparator);
  }
  private double roundoff(double num_2_round)
  {
		return (double)Math.round(num_2_round * 100000d) / 100000d;
   }
}
