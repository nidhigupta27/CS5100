package main;

import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;

import util.Feature;
import util.WeatherData;

public class GainRaio 
{
  private Feature feature2consider;
  private double partitionPoint;
  private double gainRatio = roundoff(Double.MIN_VALUE);
  private HashMap<Integer,WeatherData> XDataInTrain = new HashMap<Integer,WeatherData>();
  private HashMap<Integer,WeatherData> YDataInTrain = new HashMap<Integer,WeatherData>();
  
  public  double calcInformationRatio(HashMap<Integer,WeatherData> trainDataX,HashMap<Integer,WeatherData> trainDataY,
		                              Feature attribute,String target_val) throws IOException
  {
	  this.feature2consider = attribute;
	  this.XDataInTrain = trainDataX;
	  this.YDataInTrain = trainDataY;
	  sortTrainXYData(attribute);
  }
  private void sortTrainXYData(final Feature attrb)
  {
	 final double xValue = 0.0;
	 final double yValue = 0.0;
	  Comparator<HashMap<Integer,WeatherData>> comparator = new Comparator<HashMap<Integer,WeatherData>>()
		{
		    public int compare(HashMap<Integer,WeatherData> x, HashMap<Integer,WeatherData> y) 
			{
		    	Map.Entry<Integer, WeatherData> xkey_weatherData= (Entry<Integer, WeatherData>) x.entrySet();
		    	WeatherData xrow = xkey_weatherData.getValue();
		        for(Feature f : xrow.getFeatures())
		        {
		        	if(f.getName().contains(attrb.getName()))
		        	{
		        		xValue = Double.parseDouble((String) f.getValues().get(0));		        		
		        	}
		        }
		        Map.Entry<Integer, WeatherData> ykey_weatherData= (Entry<Integer, WeatherData>) y.entrySet();
		    	WeatherData yrow = ykey_weatherData.getValue();
		        for(Feature f : yrow.getFeatures())
		        {
		        	if(f.getName().contains(attrb.getName()))
		        	{
		        		yValue = Double.parseDouble((String) f.getValues().get(0));		        		
		        	}
		        }
				if ((xValue - yValue) > 0) return 1;
				else if ((xValue - yValue) < 0) return -1;
				else return 0;
			}
		};
		Collections.sort(this.XDataInTrain, comparator);
  }
  private double roundoff(double num_2_round)
  {
		return (double)Math.round(num_2_round * 100000d) / 100000d;
   }
}
