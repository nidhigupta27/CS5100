package main;

import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import util.Feature;
import util.WeatherData;

public class GainRaio 
{
  private Feature feature2consider;
  private double partitionPoint;
  private double gainRatio = roundoff(Double.MIN_VALUE);
  private HashMap<Integer,WeatherData> XDataInTrain = new HashMap<Integer,WeatherData>();
  private HashMap<Integer,WeatherData> YDataInTrain = new HashMap<Integer,WeatherData>();
  
  public  double calcInformationRatio(HashMap<Integer,WeatherData> trainDataX,HashMap<Integer,WeatherData> trainDataY,
		                              Feature attribute,String target_val) throws IOException
  {
	  this.feature2consider = attribute;
	  this.XDataInTrain = trainDataX;
	  this.YDataInTrain = trainDataY;
	  HashMap<Integer,Double> XDataTrainAttrbMap = new HashMap<Integer,Double>();
	  XDataTrainAttrbMap = getHashByAttrib(XDataInTrain,attribute);
	  sortByValue(XDataTrainAttrbMap);
  }
  private HashMap<Integer,Double> getHashByAttrib(HashMap<Integer,WeatherData> XDataInTrain,Feature attrb)
  {
	  
	  
  }
  public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue( Map<K, V> map )
  {
      List<Map.Entry<K, V>> list =
          new LinkedList<Map.Entry<K, V>>( map.entrySet() );
      Collections.sort( list, new Comparator<Map.Entry<K, V>>()
      {
          public int compare( Map.Entry<K, V> o1, Map.Entry<K, V> o2 )
          {
              return (o1.getValue()).compareTo( o2.getValue() );
          }
      } );

      Map<K, V> result = new LinkedHashMap<K, V>();
      for (Map.Entry<K, V> entry : list)
      {
          result.put( entry.getKey(), entry.getValue() );
      }
      return result;
  }
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  /////////////////////////////////////////
	 final double xValue = 0.0;
	 final double yValue = 0.0;
	  Comparator<HashMap<Integer,WeatherData>> comparator = new Comparator<HashMap<Integer,WeatherData>>()
		{
		  @Override
		   public int compare(HashMap<Integer,WeatherData> x, HashMap<Integer,WeatherData> y) 
			{
		    	Map.Entry<Integer, WeatherData> xkey_weatherData= (Entry<Integer, WeatherData>) x.entrySet();
		    	WeatherData xrow = xkey_weatherData.getValue();
		        for(Feature f : xrow.getFeatures())
		        {
		        	if(f.getName().equals(attrb.getName()))
		        	{
		        		xValue = Double.parseDouble((String) f.getValues().get(0));		        		
		        	}
		        }
		        Map.Entry<Integer, WeatherData> ykey_weatherData= (Entry<Integer, WeatherData>) y.entrySet();
		    	WeatherData yrow = ykey_weatherData.getValue();
		        for(Feature f : yrow.getFeatures())
		        {
		        	if(f.getName().equals(attrb.getName()))
		        	{
		        		yValue = Double.parseDouble((String) f.getValues().get(0));		        		
		        	}
		        }
				if ((xValue - yValue) > 0) return 1;
				else if ((xValue - yValue) < 0) return -1;
				else return 0;
			}
		};
		Collections.sort(XDataInTrain,comparator);
  }
  private double roundoff(double num_2_round)
  {
		return (double)Math.round(num_2_round * 100000d) / 100000d;
   }
}
